
# 5. 创建高性能的索引

索引（Mysql中也叫“键”Key）是存储引擎用来快速找到记录的一种数据结构。索引对于良好的性能非常关键。尤其是表中的数据量越来越大时，索引对性能的影响愈发重要。因此，索引优化应该是查询性能优化最有效的手段了。

## 5.1 索引基础

索引的作用就像一本书的目录一样，存储引擎在索引中找到匹配的索引记录，进而找到对应的数据行。

### 5.1.1 索引的类型

Mysql中索引是在存储引擎层实现而不是服务器层的，所以不同存储引擎的索引工作方式并不一样，也不是所有存储引擎都支持所有类型的索引。

**B-Tree索引**

- **如果没有特别指明类型，多半说的是B-Tree索引**。
- 实际上很多存储引擎使用`B+Tree数据结构`存储数据：每个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。
- 存储引擎以不同的方式使用B-Tree索引。如：MyISAM使用`前缀压缩技术`使得索引更小，并通过`数据的物理位置引用`被索引的行，而InnoDB则根据`主键引用`被索引的行。NDB集群存储引擎实际使用T-Tree结构存储这种索引。
- B-Tree索引通常意味着所有的索引列值都是`按顺序存储`的，并且每个`叶子页`到根的距离相同（？！）。
  - B-Tree索引能够加快访问数据的速度，存储引擎不再需要进行全表扫描来获取需要的数据。
    - 取而代之的是从索引的根节点开始搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点。这些指针时间上定义了子节点页中的值的上限和下限。
    - `叶子节点`比较特别，指针指向的被索引的数据，而不是其他的节点页。
    - 实际在根节点和叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关。
    - 请注意，索引对多个值进行排序的依据是CREATE TABLE语句中`定义索引时列的顺序`。

![5-1建立在B-Tree结构上的索引](5-1建立在B-Tree结构上的索引.png)

```mysql
-- 例子，后面用到。
CREATE TABLE People (
  last_name varchar(50) not null,
  first_name varchar(50) not null,
  dob date not null,
  gender enum('m','f') not null,
  key(last_name, first_name, dob)
)
```

- B-Tree索引适合于全键值、键值范围或键前缀查找。适合的查询类型如下：
  - `全值匹配`指的是和索引中所有列进行匹配。如：查找姓名为Cuba Allen、出生于1960-01-01的人。
  - `匹配最左前缀`即只使用索引的第一列。如：查找所有姓Allen的人。
  - `匹配列前缀`指匹配某一列的值的开头部分。如：查找所有以J开头的姓的人。
  - `匹配范围值`。如：查找姓在Allen和Barry之间的人。
  - `精确匹配某一列并范围匹配另外一列`。如：查找所有姓为Allen，并且名是K开头的人。
  - `只访问索引的查询（覆盖索引）`，即查询只需访问索引，而无须访问数据行。
- 一般来说，如果B-Tree可以按照某种方式查找到值，也可以按照这种方式来排序。所以，如果`ORDER BY子句`满足前面列出的集中查询类型，则这个索引也可以满足对应的排序需求。
- B-Tree索引的限制：
  - `如果不是按照索引的最左列开始查找，则无法使用索引`。如：无法查找名字叫Bill的人，也无法查找某个特定生日的人。
  - `不能跳过索引中的列`。如：无法查找姓Smith并且在某个特定日期出生的人。如果不指定名，则只能使用索引的第一列。
  - `如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找`。如：WHERE last_name='Smith' and first_name like 'J%' and dob='1976-12-23',该查询只能使用索引的前两列。（可以first_name查询数量有限，可以使用多个等于条件代替范围条件）
- 以上可见索引列的顺序多么重要。在优化性能时，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。

**哈希索引**

- 哈希索引基于哈希表实现，`只有精确匹配索引所有列才有效`。
  - 存储引擎会对所有的索引列计算一个哈希码，并且不同键值行计算出来的哈希码是不一样的。
- Mysql中只有`Memory引擎显式`支持哈希索引，也是Memory引擎表的`默认`索引类型。（Memory引擎另外也支持B-Tree索引）。除Memory引擎外，NDB集群引擎也支持唯一哈希索引。
  - Memory引擎支持`非唯一`哈希索引（如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈系条目中）

```mysql
-- 例子
CREATE TABLE testhash (
  fname varchar(50) not null,
  lname varchar(50) not null,
  key using HASH(fname)
) ENGINE=MEMORY;
```

- 哈希索引自身仅存储对应哈希值，结构十分紧凑，这让索引查找速度非常快。然而它也有限制：
  - 哈希索引只包含哈希值和行指针，并不存储字段值，所以`无法避免读取行`。
  - 哈希索引数据并不是按照索引列的值顺序存储的，所以也`无法用于排序`。
  - 不支持部分索引列匹配查找。如：列(A,B)上建立的哈希索引，索引无法只使用列A查询。
  - 只支持等值比较查询，包括`=,IN(),<=>(注意<>和<=>是不同的操作)`，也不支持任何范围查询。
  - 当出现`哈希冲突`（不同的索引值却有相同的哈希值）时，存储引擎必须遍历链表中所有的行指针，逐行比较直到找到。
    - 当哈希冲突很多的话，索引维护的代价也会很多。

哈希索引只适合某些特定的场合。如：数据仓库应用中一种典型的星型schema，需要关联很多查找表，就非常适合。

InnoDB引擎有一个特殊功能：“`自适应哈希索引` adaptive hash index”。当InnoDB注意到某些索引值被使用非常频繁时，会在内存中基于B-Tree索引之上再创建一个哈希索引，让B-Tree索引具备哈希索引的一些优点。这是一个完全自动、内部的行为，无法控制或配置，不过如有必要，完全可以关闭。

`自定义哈希索引`思路：在B-Tree的基础上创建一个伪哈希索引。还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引。这样只需要很小的索引就可以为超长的键创建索引。

```mysql
SELECT id FROM url WHERE url="http://www.mysql.com";

-- 删除url列原索引，新增一个被索引的url_crc列，使用CRC32做哈希
SELECT id FROM url WHERE url="http://www.mysql.com"
AND url_crc=CRC32("http://www.mysql.com");

-- 创建表，使用触发器自动维护哈希值
CREATE TABLE pseudohash (
  id int unsigned not null auto_increment,
  url varchar(255) not null,
  url_crc int unsigned not null default 0,
  primary key(id)
);

-- 临时修改语句分割符，这样可以在触发器定义中使用分号
DELIMITER //

CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON pseudohash FOR EACH ROW BEGIN
SET NEW.url_crc=crc32(NEW.url);
END;
//

CREATE TRIGGER pseudohash_crc_upd BEFORE UPDATE ON pseudohash FOR EACH ROW BEGIN
SET NEW.url_crc=crc32(NEW.url);
END;
//

DELIMITER ;

-- SHA1()和MD5()属于强加密函数，设计目标是最大限度消除冲突，这里并没有这样高的要求
-- 简单函数的冲突在一个可以接受的范围内，同时又提供更好的性能
-- 如果数据表非常大，CRC32()会出现大量哈希冲突，可以考虑自己实现一个简单的64位哈希函数
SELECT CONV(RIGHT(MD5('http://www.mysql.com/'),16),16,10) as HASH64;

-- CRC32()返回的是32位整数，当索引有93000条记录时出现冲突的概率是1%。
-- 要避免冲突，必须在WHERE条件中带入哈希值和对应列的值。
SELECT word,crc FROM words WHERE crc=CRC32('gnu') AND word='gnu';

-- 可以考虑使用FNV64()作为哈希函数，移植自Percona Server的插件
-- 哈希值为64位，速度快，且冲突比CRC32()要少很多。
```

**其他索引**

- 空间数据索引： 
  - MyIsAM支持空间索引，用来存储地理数据。（并不完善）
    - 无需前缀查询，可以使用任意维度来组合查询。
    - 必须使用Mysql的 GIS相关函数来维护数据。
  - 开源关系数据库中GIS解决方案比较好的是 PostgreSQL的`PostGIS`
- `全文索引`：一种特殊的索引，主要查找文本中的关键字，而不是直接比较索引值。全文检索跟其他索引匹配使用方式完全不同，有很多需要注意的细节：停用词、词干和复数、布尔搜索等。它更类似搜索引擎。
- 第三方索引：TokuDB使用分形树索引

## 5.2 索引的优点

索引不仅仅可以让服务器快速定位到表的指定位置，总结有如下三个优点：
- 大大减小了服务器需要扫描的数据量
- 可以帮助服务器避免排序和临时表
- 可以将随机IO变成顺序IO

Lahdenmaki和Leach在《Relational Database Index Design and the Optimizers》提到：
评价索引是否适合某个查询的 __“三星系统”__：
1. `索引将相关的记录放到一起则获得一星；`
2. `索引中的数据顺序和查找中的排序顺序一致则获得二星；`
3. `索引中的列包含了查询中需要的全部列则获得三星；`

只有当索引索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。
- 对于非常小的表，大部分情况下简单的全表扫描更高效
- 对于中大型表，索引就比较有效
- 对于特大型表，建立和使用索引的代价将随之增长。这时需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配。如：`分区技术`
- 如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特征。如：执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据。
- 对于大型系统，TB级别的数据，定位单条记录意义不大，所以经常会使用块`级别元数据技术`代替索引。Infobright就是类似实现。

## 5.3 高性能的索引策略

### 5.3.1 独立的列

独立的列指：索引列不能是表达式的一部分，也不能是函数的参数

```mysql
-- 不能使用actor_id列的索引。
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;

-- 另一个错误
SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

### 5.3.2 前缀索引和索引选择性

有时候需要索引很长的字符串，这会让索引变得大又慢。一个策略是前面提到的模拟哈希索引。除此之外呢？通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。

`索引的选择性`是指，不重复的索引值（也称为基数 cardinaality）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让Mysql查找时过滤掉更多的行。唯一索引选择性是1,也是最好的。

- 对于BLOB，TEXT或很长的VARCHAR类型的列，必须使用前缀索引，因为Mysql不允许索引这些列的完整长度。
- 诀窍在于选择足够长的前缀以保证较高的选择性，同时不能太长（以便节约空间）。`换言之，前缀的基数应该接近于完整列的基数。`
  - 决定前缀的合适长度方法：
    - 需要找到`最常见的值`的`出现次数`列表，然后和最常见的前缀列表比较。
    - 另一个方法是：计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。
  
```mysql
-- 决定前缀长度方法1：比较前缀长度谁更接近最常见值出现次数
select count(*) as cnt, city
from sakila.city_demo group by city order by cnt desc limit 10;

select count(*) as cnt, LEFT(city,3) as pref
from sakila.city_demo group by pref order by cnt desc limit 10;

select count(*) as cnt, LEFT(city,7) as pref
from sakila.city_demo group by pref order by cnt desc limit 10;

-- 决定前缀长度方法2：比较前缀长度谁更接近完整列选择性
select count(distinct city)/count(*) from sakila.city_demo;

select count(distinct left(city,3))/count(*) as sel3,
count(distinct left(city,4))/count(*) as sel4,
count(distinct left(city,5))/count(*) as sel5,
count(distinct left(city,6))/count(*) as sel6,
count(distinct left(city,7))/count(*) as sel7
from sakila.city_demo;

-- 演示创建前缀索引
ALTER TABLE sakila.city_demo ADD KEY(city(7));
```

- 缺点：无法使用前缀索引做ORDER BY和GROUP BY，也无法做覆盖扫描。
- 一个常见场景：针对很长的十六进制唯一ID（如网站SESSION）使用前缀索引。
- 后缀索引的变通：字符串反转后储存，并基于此建立前缀索引。

### 5.3.3 多列索引



### 5.3.4 选择和是的索引列顺序
### 5.3.5 聚簇索引
### 5.3.6 覆盖索引
### 5.3.7 使用索引扫描来做排序
### 5.3.8 压缩（前缀压缩）索引
### 5.3.9 冗余和重复索引
### 5.3.10 未使用的索引
### 5.3.11 索引和锁
## 5.4 索引案例学习
### 5.4.1 支持多种过滤条件
### 5.4.2 避免多个范围条件
### 5.4.3 优化排序
## 5.5 维护索引和表
### 5.5.1 找到并修复损坏的表
### 5.5.1 更新索引统计信息
### 5.5.1 减少索引和数据的碎片